#include "shader.hpp"

#ifdef __linux__
#include <stdexcept>
#include <fstream>

#include "platform/opengl.hpp"

namespace rg
{

    class ShaderImpl
    {
        friend class Shader;
    
        GLuint m_id;
    };

    Shader::Shader()
    {
        m_impl = new ShaderImpl();
    }

    Shader::~Shader()
    {
        delete m_impl;
    }

    GLenum shader_type_to_glenum(Shader::Type shaderType)
    {
        switch(shaderType)
        {
            case Shader::Type::VERTEX:
                return GL_VERTEX_SHADER;
            case Shader::Type::FRAGMENT:
                return GL_FRAGMENT_SHADER;
            case Shader::Type::GEOMETRY:
                return GL_GEOMETRY_SHADER;
            case Shader::Type::COMPUTE:
                return GL_COMPUTE_SHADER;
            defualt:
                throw std::runtime_error("Invalid shader type");
        }

        return GL_INVALID_ENUM;
    }


    bool Shader::load(Shader::Type shaderType, const std::filesystem::path& source)
    {
        std::ifstream t(source);

        if(!t.is_open())
            return false;

        std::stringstream ss;
        ss << t.rdbuf();
        std::string sourceCode ss->str();

        if(sourceCode.empty())
            return false;

        m_impl->m_id = gl::createShader(shader_type_to_glenum(shaderType));
        if(m_impl->m_id == 0)
            return false;
        
        gl::shaderSource(m_impl->m_id, 1, sourceCode.c_str(), NULL);
        gl::compileShader(m_impl->m_id);

        int success = 0;
        gl::getShaderiv(m_impl->m_id, GL_COMPILE_STATUS, &success);
        if(!success)
        {
            std::string infoLong(512, '\0');
            gl::getShaderInfoLog(m_impl->m_id, 512, NULL, infoLog.c_str());
            unload();
            return false;
        }

        return true;
    }

    void Shader::unload()
    {
        gl::deleteShader(m_impl->m_id);
        m_impl->m_id = 0;
    }


}

#endif
